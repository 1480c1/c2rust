This section details the refactoring script used to transform the initial Rust
translation of `robotfindskitten`, as generated by `c2rust transpile`, into a
safe Rust program.  We divide the refactoring process into several major steps:

 * `ncurses` macro cleanup: The `ncurses` library implements parts of its API
   using C preprocessor macros, and a few of those macros expand to relatively
   complex code.  We replace these expanded macro bodies with calls to
   equivalent functions, which are easier to recognize and refactor.

 * String formatting: `robotfindskitten` calls several `printf`-style
   string-formatting functions.  We replace these unsafe variable-argument
   function calls with safe wrappers using Rust's `format` family of macros.
   Aside from improving memory safety, this also allows the Rust compiler to
   more accurately typecheck the format arguments, which is helpful for later
   type-directed refactoring passes.

 * Static string constants: `robotfindskitten` has two global variables
   containing string constants, which are translated to Rust as `static mut`
   definitions containing C-style `*const c_char` pointers.  We refactor to
   remove both sources of unsafety, replacing raw pointers with checked
   `&'static str` references and converting the mutable `static`s to immutable
   ones.

 * Heap allocations: `robotfindskitten` uses a heap allocated array to track
   the objects in the game world.  This array is represented as a raw pointer,
   and the underlying storage is managed explicitly with `malloc` and `free`.
   We replace the array with a memory-safe collection type, avoiding unsafe FFI
   calls and preventing out-of-bounds memory accesses.

 * Using the `pancurses` library: Calling `ncurses` library functions directly
   through the Rust FFI requires unsafe code at every call site.  We replace
   unsafe `ncurses` function calls with calls to the safe wrappers provided by
   the `pancurses` crate.

 * Moving global state to the stack: `robotfindskitten` uses mutable global
   variables to store the game state, which turn into unsafe `static mut`
   definitions in Rust.  We collect all such variables into a single
   stack-allocated struct, which can be mutated without unsafety.

 * `libc` calls: We replace calls to miscellaneous `libc` functions, such as
   `sleep` and `rand`, with calls to safe Rust equivalents.

 * Function argument types: Two remaining functions in `robotfindskitten` take
   raw pointers as arguments.  We change each function's signature to use only
   safe Rust types, and update their callers to match.

 * String conversion cleanup: Several of the previous refactoring passes insert
   conversions between Rust and C string types.  In several places, these
   conversions form cycles, such as `&str -> *const c_char -> &str`, which are
   both redundant and a source of unsafe code.  We remove such conversion
   cycles to avoid unnecessary raw pointer manipulation.

 * Removing `unsafe` qualifiers: At this point, we have removed all the unsafe
   code we can.  We remove unused `unsafe` qualifiers from blocks and
   functions, leaving a correct Rust translation of `robotfindskitten` with
   only a single line of unsafe code.


# `ncurses` macro cleanup

`robotfindskitten` uses a variety of macros provided by the `ncurses` library.
Since `c2rust transpile` runs the C preprocessor before translating to Rust,
the expansions of those macros effectively get inlined in the Rust code at each
call site.  In many cases, this is harmless: for example, `move(y, x)` expands
to `wmove(stdscr, y, x)`, which is not much harder to refactor than the
original.  However, the `attr_get` and `attrset` macros are more complex: they
expand to multiple lines of code involving several conditionals and complex
expressions.  In this step, we convert the expanded code into simple function
calls, which are easier to manipulate in later refactoring passes.

Fortunately, the `ncurses` library provides functions implementing the same
operations as the troublesome macros, and we can call those functions through
Rust's FFI.  We begin by providing Rust declarations for these foreign
functions.  For ease of reading, we put the new declarations just after the
existing `extern "C"` block:

```refactor
select target 'crate; child(foreign_mod); last;' ;
create_item
    '
        extern "C" {
            fn wattr_get(win: *mut WINDOW, attrs: *mut attr_t,
                pair: *mut libc::c_short, opts: *mut libc::c_void) -> libc::c_int;
            fn wattrset(win: *mut WINDOW, attrs: libc::c_int) -> libc::c_int;
        }
    '
    after ;
```

Now we can use `rewrite_expr` to find Rust code that comes from the expansions
of the `wattrset` macro and replace it with calls to the `wattrset` function:

```refactor
rewrite_expr
    '
        if !(__win as *const libc::c_void).is_null() {
            (*__win)._attrs = __attrs
        } else {
        }
    '
    'wattrset(__win, __attrs as libc::c_int)' ;
```

The `__win` and `__attrs` metavariables in the pattern correspond to the
arguments of the original C macro, and are used in the replacement to construct
the equivalent Rust function call.

Next, we do the same thing for the more complicated `wattr_get` macro:

```refactor
rewrite_expr
    '
        if !(__win as *const libc::c_void).is_null() {
            if !(&mut __attrs as *mut attr_t as *const libc::c_void).is_null() {
                __attrs = (*__win)._attrs
            } else {
            };
            if !(&mut __pair as *mut libc::c_short as *const libc::c_void).is_null() {
                __pair = (((*__win)._attrs as libc::c_ulong
                    & ((1u32 << 8i32).wrapping_sub(1u32) << 0i32 + 8i32) as libc::c_ulong)
                    >> 8i32) as libc::c_int as libc::c_short
            } else {
            };
        } else {
        }
    '
    'wattr_get(__win, &mut __attrs, &mut __pair, ::std::ptr::null_mut())' ;
```

Finally, we are done with this bit of cleanup, so we write the changes to disk
before continuing on:

```refactor
commit ;
```


# String formatting

`robotfindskitten` calls several `printf`-style variable-argument functions to
perform string formatting.  Since variable-argument function calls are
considered unsafe in Rust, we must replace these with Rust-style string
formatting using `format!` and related macros.  Specifically, for each string
formatting function such as `printf`, we will create a safe wrapper
`fmt_printf` that takes a Rust `fmt::Arguments` object, and replace
`printf(...)` calls with `fmt_printf(format_args!(...))`.  This approach
isolates all the unsafety into the `fmt_printf` wrapper, where it can be
eliminated by later passes.

The replacement itself happens in two steps.  First, we convert `printf` calls
from `printf(<C format args...>)` to `printf(format_args!(<Rust format
args...>))`.  Note that the code does not typecheck in this intermediate state:
C's `printf` function cannot accept the `std::fmt::Arguments` produced by the
`format_args!` macro.  The second step then replaces the `printf` call with a
call to the `fmt_printf` wrapper, which does accept `std::fmt::Arguments`.

## `printf` format argument conversion

We run a few commands to mark the nodes involved in string formatting, before
finally running the `convert_format_args` command to perform the actual
transformation.

First, we use `select` and `mark_arg_uses` to mark the first argument of every
`printf` call as `target`s:

```refactor
select target 'item(printf);' ;
mark_arg_uses 0 target ;
```

`convert_format_args` will treat the `target` argument at each call site as a
`printf`-style format string, and will treat all later arguments as format
args.

Next, we mark the format string literal with `fmt_str`, which tells
`convert_format_args` the exact string literal it should use as the format
string.  This usually is not the same as the `target` argument, since
`c2rust-transpile` inserts several casts to turn a Rust string literal into a
`*const libc::c_char`.

```refactor
select fmt_str 'marked(target); desc(expr && !match_expr(__e as __t));' ;
```

With both `target` and `fmt_str` marks in place, we can apply the actual
transformation:

```refactor
convert_format_args ;
```

Finally, we clean up from this step by clearing all the marks.

```refactor 
clear_marks ;
```

`commit` would also
clear the marks, but we don't want to `commit` these changes until we've fixed
the type errors introduced in this step.

## Creating a `printf` wrapper

As a reminder, we currently have code that looks like this:

```Rust
printf(format_args!("Hello, {}!\n", "world"))
```

`printf` itself can't accept the `std::fmt::Arguments` returned by
`format_args!`, so we will define a wrapper that does accept
`std::fmt::Arguments` and then rewrite these `printf` calls to call the wrapper
instead.

First, we insert the wrapper:

```refactor
select target 'crate; child(foreign_mod); last;' ;
create_item
    '
        fn fmt_printf(args: ::std::fmt::Arguments) -> libc::c_int {
            print!("{}", args);
            0
        }
    '
    after ;
```

Since Rust provides a `print!` macro with similar functionality to `printf`,
our "wrapper" actually just calls `print!` directly, avoiding the string
conversions necessary to call the actual C `printf`.  (See the next subsection
for an example of a "real" wrapper function.)

With the wrapper in place, we can now update the call sites:

```refactor
rewrite_expr 'printf' 'fmt_printf' ;
```

Now that we've finished this step and the crate typechecks again, we can safely
commit the changes:

```refactor
commit ;
```

## Other string formatting functions

Aside from `printf`, `robotfindskitten` also uses the `ncurses` `printw` and
`mvprintw` string-formatting functions.  The refactoring script for `printw` is
similar to the previous two steps combined:

```refactor
select target 'item(printw);' ;
mark_arg_uses 0 target ;
select fmt_str 'marked(target); desc(expr && !match_expr(__e as __t));' ;

convert_format_args ;

clear_marks ;

select target 'crate; child(foreign_mod); last;' ;
create_item
    '
        fn fmt_printw(args: ::std::fmt::Arguments) -> libc::c_int {
            unsafe {
                ::printw(b"%s\0" as *const u8 as *const libc::c_char,
                         ::std::ffi::CString::new(format!("{}", args))
                             .unwrap().as_ptr())
            }
        }
    '
    after ;
rewrite_expr 'printw' 'fmt_printw' ;
commit ;
```

Aside from replacing the name `printf` with `printw`, the other notable
difference from the `printf` script is the body of `fmt_printw`.  There is no
convenient replacement for `printw` in the Rust standard library, so instead we
call the original `printw` function, passing in the result of Rust string
formatting (converted to a C string) as an argument.

The `mvprintw` replacement is also similar, just with a few extra arguments:

```refactor
select target 'item(mvprintw);' ;
mark_arg_uses 2 target ;
select fmt_str 'marked(target); desc(expr && !match_expr(__e as __t));' ;

convert_format_args ;

clear_marks ;

select target 'crate; child(foreign_mod); last;' ;
create_item
    '
        fn fmt_mvprintw(y: libc::c_int, x: libc::c_int,
                        args: ::std::fmt::Arguments) -> libc::c_int {
            unsafe {
                ::mvprintw(y, x, b"%s\0" as *const u8 as *const libc::c_char,
                         ::std::ffi::CString::new(format!("{}", args))
                             .unwrap().as_ptr())
            }
        }
    '
    after ;
rewrite_expr 'mvprintw' 'fmt_mvprintw' ;
commit ;
```


# Static string constant - `ver`

`robotfindskitten` defines a static string constant, `ver`, to store the game's
version.  Using `ver` is currently unsafe, first because its Rust type is a raw
pointer (`*mut c_char`), and second because it's mutable.  To make `ver` usage
safe, we first change its type to `&'static str` (and fix up the resulting type
errors), and then we change it from a `static mut` to an ordinary immutable
`static`.  Note that we must change the type first because Rust does not allow
raw pointers to be stored in safe (non-`mut`) `static`s.

We change the type using `rewrite_ty`:

```refactor
select target 'item(ver); child(ty);' ;
rewrite_ty 'marked!(*mut libc::c_char)' "&'static str" ;
delete_marks target ;
```

The combination of `select` and the `marked!` matching form ensures that only
`ver`'s type annotation is modified.  We delete the mark afterward, since it's
no longer needed.

Simply replacing `*mut c_char` with `&str` introduces type errors throughout
the crate.  The initializer for `ver` still has type `*mut c_char`, and all
uses of `ver` are still expecting a `*mut c_char`.

## Fixing `ver`'s initializer

Fixing the `ver` initializer is straightforward: we simply remove all the
casts, then convert the binary string (`&[u8]`) literal to an ordinary string
literal.  For the casts, we mark all cast expressions in `ver`'s definition,
then replace each one with its subexpression:

```refactor
select target 'item(ver); desc(match_expr(__e as __t));' ;
rewrite_expr 'marked!(__e as __t)' '__e' ;
delete_marks target ;
```

Only the binary string literal remains, so we mark it and change it to an
ordinary `str`:

```refactor
select target 'item(ver); child(expr);' ;
bytestr_to_str ;
delete_marks target ;
```

## Fixing `ver`'s uses

`ver`'s initializer is now well-typed, but its uses are still expecting a `*mut
c_char` instead of a `&str`.  To fix these up, we use the `type_fix_rules`
command, which rewrites expressions anywhere a type error occurs:

```refactor
type_fix_rules '*, &str, *const __t => __old.as_ptr()' ;
```

Here we run `type_fix_rules` with only one rule: in any position (`*`), if an
expression has type `&str` but is expected to have a raw pointer type (`*const
__t`), then wrap the original expression in a call to `.as_ptr()`.  This turns
out to be enough to fix all the errors at uses of `ver`.


## Making `ver` immutable

Now that all type errors have been corrected, we can finish our refactoring of
`ver`.  We make it immutable, then commit the changes.

```refactor
select target 'item(ver);' ;
set_mutability imm ;

commit ;
```


# Static string array - `messages`

Aside from `ver`, `robotfindskitten` contains a static array of strings, called
`messages`.  Like `ver`, accessing `messages` is unsafe because each element is
a raw `*mut c_char` pointer and because `messages` itself is a `static mut`.

We rewrite the type and initializer of `messages` using the same strategy as
for `ver`:

```refactor
select target 'item(messages); child(ty); desc(ty);' ;
rewrite_ty 'marked!(*mut libc::c_char)' "&'static str" ;
delete_marks target ;
select target 'item(messages); child(expr); desc(expr);' ;
rewrite_expr 'marked!(__e as __t)' '__e' ;
bytestr_to_str ;
delete_marks target ;
```

We use `type_fix_rules` to fix up the uses of `messages`, as we did for `ver`:

```refactor
type_fix_rules
    '*, &str, *const __t => __old.as_ptr()'
    '*, &str, *mut __t => __old.as_ptr() as *mut __t' ;
```

Here we needed a second rule for `*mut` pointers, similar to the one for
`*const`, because `robotfindskitten` mistakenly declares `messages` as an array
of `char*` instead of `const char*`.

With all type errors fixed, we can make `messages` immutable and commit the
changes:

```refactor
select target 'item(messages);' ;
set_mutability imm ;

commit ;
```


# Heap allocations

The `screen` variable stores a heap-allocated two-dimensional array,
represented in C as an `int**`.  In Rust, this becomes `*mut *mut c_int`, which
is unsafe to access.  We replace it with `CArray<CArray<c_int>>`, where
`CArray` is a memory-safe collection type provided by the `c2rust_runtime`
library.  `CArray` is convenient for this purpose because it supports C-style
initialization and access patterns (including pointer arithmetic) while still
guaranteeing memory safety.

We actually perform the conversion from `*mut` to `CArray` in two steps.
First, we replace `*mut` with the simpler `CBlockPtr` type, also defined in
`c2rust_runtime`.  `CBlockPtr` provides some limited bounds checking, but
otherwise functions much like a raw pointer.  It serves as a useful
intermediate step, letting us fix up the differences between the raw-pointer
and `CArray` APIs in two stages instead of attempting to do it all at once.
Once `screen` has been fully converted to `CBlockPtr<CBlockPtr<c_int>>`, we
finish the conversion to `CArray` in the second step.

As a preliminary, we need to add an import of the `c2rust_runtime` library:

```refactor
select target 'crate;' ;
create_item 'extern crate c2rust_runtime;' inside ;
```

Now we can proceed with the actual refactoring.

## Converting to `CBlockPtr`

We further break down the transition from `*mut *mut c_int` to
`CBlockPtr<CBlockPtr<c_int>>` into two steps, first converting the inner
pointer (leaving the overall type as `*mut CBlockPtr<c_int>`) and then the
outer.  We change the type annotation first, as we did for `var` and
`messages`:

```refactor
select target 'item(screen); child(ty);' ;
rewrite_ty 'marked!(*mut *mut __t)'
    '*mut ::c2rust_runtime::CBlockPtr<__t>' ;
```

This introduces type errors, letting us easily find (and fix) related
expressions using `type_fix_rules`:

```refactor
type_fix_rules
    'rval, *mut __t, ::c2rust_runtime::CBlockPtr<__u> =>
        unsafe { ::c2rust_runtime::CBlockPtr::from_ptr(__old) }'
    'rval, *mut __t, *mut __u => __old as *mut __u'
    ;
```

The first rule provided here handles the later part of `screen`'s
initialization, where the program allocates a `*mut c_int` array (now
`CBlockPtr<c_int>`) for each row of the screen.  The second rule handles the
earlier part, where it allocates the top-level `*mut *mut c_int` (now `*mut
CBlockPtr<c_int>`).  Both allocations now need a cast, since the type of the
rows has changed.

One category of type errors remains: the initialization code tries to
dereference the result of `offset`ting the array pointer, which is not possible
directly with the `CBlockPtr` API.  We add the necessary method call using
`rewrite_expr`:

```refactor
rewrite_expr
    '*typed!(__e, ::c2rust_runtime::block_ptr::CBlockOffset<__t>)'
    '*__e.as_mut()' ;
```

Here, the pattern filters for dereferences of `CBlockOffset` expressions, which
result from calling `offset` on a `CBlockPtr`, and adds a call to `as_mut()`
before the dereference.

The conversion of `screen` to `*mut CBlockPtr<c_int>` is now complete.  The
conversion to `CBlockPtr<CBlockPtr<c_int>>` uses a similar refactoring script:

```refactor
select target 'crate; item(screen); child(ty);' ;
rewrite_ty 'marked!(*mut __t)'
    '::c2rust_runtime::CBlockPtr<__t>' ;
type_fix_rules
    'rval, *mut __t, ::c2rust_runtime::CBlockPtr<__u> =>
        unsafe { ::c2rust_runtime::CBlockPtr::from_ptr(__old) }'
    'rval, *mut __t, *mut __u => __old as *mut __u'
    ;
rewrite_expr
    '*typed!(__e, ::c2rust_runtime::block_ptr::CBlockOffset<__t>)'
    '*__e.as_mut()' ;
```

The only change is in the `rewrite_ty` step.

There's one last bit of cleanup to perform: now that `screen` has the desired
`CBlockPtr<CBlockPtr<c_int>>` type, we can rewrite the allocations that
initialize it.  At this point the allocations use the unsafe `malloc` function
followed by the unsafe `CBlockPtr::from_ptr`, but we can change that to use the
safe `CBlockPtr::alloc` method instead:

```refactor
rewrite_expr 'malloc(__e) as *mut __t as *mut __u' 'malloc(__e) as *mut __u' ;
rewrite_expr
    '::c2rust_runtime::CBlockPtr::from_ptr(malloc(__e) as *mut __t)'
    '::c2rust_runtime::CBlockPtr::alloc(
        __e as usize / ::std::mem::size_of::<__t>())'
    ;
```

This doesn't remove the `unsafe` blocks wrapping each allocation - we leave
those until the end of our refactoring, when we remove unnecessary `unsafe`
blocks throughout the entire crate at once.

At this point, the refactoring of `screen` to  is
done, and we can commit the changes:

```refactor
commit ;
```

## Converting to `CArray`

The `CArray` and `CBlockPtr` APIs are deliberately quite similar, which makes
this part of the `screen` refactoring fairly straightforward.

First, we replace all uses of `CBlockPtr` with `CArray`, both in types and in
function calls:

```refactor
rewrite_ty '::c2rust_runtime::CBlockPtr<__t>' '::c2rust_runtime::CArray<__t>' ;
rewrite_expr
    '::c2rust_runtime::CBlockPtr::from_ptr'
    '::c2rust_runtime::CArray::from_ptr' ;
rewrite_expr
    '::c2rust_runtime::CBlockPtr::alloc'
    '::c2rust_runtime::CArray::alloc' ;
```

Next, we fix up calls to `offset`.  Unlike `CBlockPtr` (and raw pointers in
general), `CArray` distinguishes between mutable and immutable offset pointers.
We handle this by simply replacing all `offset` calls with `offset_mut`:

```refactor
rewrite_expr
    'typed!(__e, ::c2rust_runtime::CArray<__t>).offset(__f)'
    '__e.offset_mut(__f)' ;
```

This works fine for `robotfindskitten`, though in other codebases it may be
necessary to properly distinguish mutable and immutable uses of `offset`.

With this change, the code typechecks with `screen`s new memory-safe type, so
we could stop here.  However, unlike `CBlockPtr`, `CArray` supports array
indexing - `ptr[i]` - in place of the convoluted `*arr.offset(i).as_mut()`
syntax.  So we perform a simple rewrite to make the code a little easier to
read:

```refactor
rewrite_expr
    'typed!(__e, ::c2rust_runtime::CArray<__t>).offset_mut(__f).as_mut()'
    '&mut __e[__f as usize]' ;
rewrite_expr '*&mut __e' '__e' ;

commit ;
```


# Using the `pancurses` library

The `pancurses` library provides safe wrappers around `ncurses` APIs.  Since
the `pancurses` and `ncurses` APIs are so similar, we can automatically convert
the unsafe `ncurses` FFI calls in `robotfindskitten` to safe `pancurses` calls,
avoiding the need to maintain safe wrappers in `robotfindskitten` itself.

There are two preliminary steps before we do the actual conversion.  First, we
must import the `pancurses` library:

```refactor
select target 'crate;' ;
create_item 'extern crate pancurses;' inside ;
```

And second, we must create a global variable to store the main `pancurses`
`Window`:

```refactor
select target 'crate;' ;
create_item 'static mut win: Option<::pancurses::Window> = None;' inside ;
```

`pancurses` doesn't have an equivalent of the global `stdscr` window that
`ncurses` provides.  Instead, the `pancurses` initialization function creates
an initial `Window` object that must be passed around to each function that
updates the display.  We store that initial `Window` in the global `win`
variable so that it's accessible everywhere that `stdscr` is used.

Note that making `win` a `static mut` makes it unsafe to access.  However, a
later refactoring pass will gather up all `static mut`s, including `win`,
and collect them into a stack-allocated struct, at which point accessing `win`
will no longer be unsafe.

## General library calls

We convert `ncurses` library calls to `pancurses` ones in a few stages.

First, for functions that don't require a window object, we simply replace each
`ncurses` function with its equivalent in the `pancurses` library:

```refactor
rewrite_expr 'nonl' '::pancurses::nonl' ;
rewrite_expr 'noecho' '::pancurses::noecho' ;
rewrite_expr 'cbreak' '::pancurses::cbreak' ;
rewrite_expr 'has_colors' '::pancurses::has_colors' ;
rewrite_expr 'start_color' '::pancurses::start_color' ;
rewrite_expr 'endwin' '::pancurses::endwin' ;
rewrite_expr 'init_pair' '::pancurses::init_pair' ;
```

Next, functions taking a window are replaced with method calls on the static
`win` variable we defined earlier:

```refactor
rewrite_expr 'wrefresh(stdscr)' 'win.refresh()' ;
rewrite_expr 'wrefresh(curscr)' 'win.refresh()' ;
rewrite_expr 'keypad(stdscr, __bf)' 'win.keypad(__bf)' ;
rewrite_expr 'wmove(stdscr, __my, __mx)' 'win.mv(__my, __mx)' ;
rewrite_expr 'wclear(stdscr)' 'win.clear()' ;
rewrite_expr 'wclrtoeol(stdscr)' 'win.clrtoeol()' ;
rewrite_expr 'waddch(stdscr, __ch)' 'win.addch(__ch)' ;

rewrite_expr
    'wattr_get(stdscr, __attrs, __pair, __e)'
    '{
        let tmp = win.attrget();
        *__attrs = tmp.0;
        *__pair = tmp.1;
        0
    }' ;
rewrite_expr
    'wattrset(stdscr, __attrs)'
    'win.attrset(__attrs as ::pancurses::chtype)' ;
```

For simplicity, we write `win.f(...)` in the `rewrite_expr` replacement
arguments, even though `win` is actually an `Option<Window>`, not a `Window`.
Later, we replace `win` with `win.as_ref().unwrap()` throughout the crate to
correct the resulting type errors.

We next replace some `ncurses` global variables with calls to corresponding
`pancurses` functions:

```refactor
rewrite_expr 'LINES' 'win.get_max_y()' ;
rewrite_expr 'COLS' 'win.get_max_x()' ;
```

Finally, we handle a few special cases.

`waddnstr` takes a string argument, which in general could be any `*const
c_char`.  However, `robotfindskitten` calls it only on string literals, which
lets us perform a more specialized rewrite that avoids unsafe C string
conversions:

```refactor
rewrite_expr
    'waddnstr(stdscr, __str as *const u8 as *const libc::c_char, __n)'
    "win.addnstr(::std::str::from_utf8(__str).unwrap().trim_end_matches('\0'),
                 __n as usize)" ;
```

`intrflush` has no `pancurses` equivalent, so we replace it with a no-op of the
same type:

```refactor
rewrite_expr 'intrflush(__e, __f)' '0' ;
```

That covers all of the "ordinary" `ncurses` functions used in
`robotfindskitten`.  The remaining subsections cover the more complex cases.

## String formatting

We previously replaced calls to the `ncurses` `printw` and `mvprintw`
string-formatting functions with code using Rust's safe string formatting
macros.  This removes unsafety from the call site, but uses wrapper functions
(`fmt_printw` and `fmt_mvprintw`) that call unsafe code internally.  But now
that we are using the `pancurses` library, we can replace those wrappers with
safer equivalents.

```refactor
select target 'item(fmt_printw);' ;
create_item '
    fn fmt_printw(args: ::std::fmt::Arguments) -> libc::c_int {
        unsafe {
            win.printw(&format!("{}", args))
        }
    }
' after ;
delete_items ;
clear_marks ;

select target 'item(fmt_mvprintw);' ;
create_item '
    fn fmt_mvprintw(y: libc::c_int, x: libc::c_int,
                    args: ::std::fmt::Arguments) -> libc::c_int {
        unsafe {
            win.mvprintw(y, x, &format!("{}", args))
        }
    }
' after ;
delete_items ;
clear_marks ;
```

The wrappers still use unsafe code to access `win`, a `static mut`, but no
longer make FFI calls or manipulate raw C strings.  When we later remove all
`static mut`s from the program, these functions will become entirely safe.

## Input handling

Adapting `ncurses`-based input handling to use `pancurses` requires some extra
care.  The `pancurses` `getch` function returns a Rust enum, while the
`ncurses` version simply returns an integer.  `robotfindskitten` matches those
integers against various `ncurses` keycode constants, which, after macro
expansion, become integer literals in the Rust code.

The more idiomatic approach would be to replace each integer literal with the
matching `pancurses::Input` enum variant when switching from `ncurses` `getch`
to the `pancurses` version.  However, we instead take the easier approach of
converting `pancurses::Input` values back to `ncurses` integer keycodes, so
the existing `robotfindskitten` input handling code can remain unchanged.

First, we inject a translation function from `pancurses` to `ncurses` keycodes:

```refactor
select target 'item(initialize_ncurses);' ;
create_item '
    fn encode_input(inp: Option<::pancurses::Input>) -> libc::c_int {
        use ::pancurses::Input::*;
        let inp = match inp {
            Some(x) => x,
            None => return -1,
        };
        match inp {
            // TODO: unicode inputs in the range 256 .. 512 can
            // collide with ncurses special keycodes
            Character(c) => c as u32 as libc::c_int,
            Unknown(i) => i,
            special => {
                let idx = ::pancurses::SPECIAL_KEY_CODES.iter()
                    .position(|&k| k == special).unwrap();
                let code = idx as i32 + ::pancurses::KEY_OFFSET;
                if code > ::pancurses::KEY_F15 {
                    code + 48
                } else {
                    code
                }
            },
        }
    }
' after ;
```

Then, we translate `ncurses` `wgetch` calls to use the `pancurses` `getch`
method, wrapping the result in `encode_input` to keep the results unchanged.

```refactor
rewrite_expr 'wgetch(stdscr)' '::encode_input(win.getch())' ;
```

## Final steps

As mentioned previously, we use `win` to obtain the current window object
throughout the `ncurses` refactoring process, even though `win` is actually an
`Option<Window>`, not a `Window`.  Now that we are done with all the rewrites,
we can update thote uses to access the `Window` properly:

```refactor
rewrite_expr 'win' 'win.as_ref().unwrap()' ;
```

The final step is to initialize `win`.  This corresponds to the call to the
`ncurses` `initscr` initialization function:

```refactor
rewrite_expr 'initscr()' 'win = Some(::pancurses::initscr())' ;
```

We save this for last only so that the `win` to `win.as_ref().unwrap()` rewrite
doesn't produce an erroneous assignment `win.as_ref().unwrap() = ...`.

At this point, we are done with the current refactoring step:
`robotfindskitten` has been fully adapted to use the safe `pancurses` API in
place of raw `ncurses` FFI calls.

```refactor
commit
```


# Moving global state to the stack

`robotfindskitten` uses global variables - `static mut`s in Rust - to store the
game state.  Accessing these globals is unsafe, due to the difficulty of
preventing simultaneous borrowing and mutation.  In this refactoring step, we
move the global state onto the stack and pass it by reference to every function
that needs it, which allows the borrow checker to analyze its usage and ensure
safety.

Most of the work in this step is handled by the `static_to_local_ref`
refactoring command.  This command identifies all functions that use a given
static, and modifies those functions to access the global through a reference
(passed as an argument to the function) instead of accessing it directly.  (See
the `static_to_local_ref` command documentation for examples.)

However, running `static_to_local_ref` separately on each of
`robotfindskitten`'s seven global variables would add up to seven new arguments
to many of `robotfindskitten`'s functions, making their signatures difficult to
read.  Instead, we proceed in two steps.  First, we gather up all the global
variables into a single global struct.  Then, we run `static_to_local_ref` on
just the struct, achieving safety while adding only a single new argument to
each affected function.


We collect the statics into a struct using `static_collect_to_struct`:

```refactor
select target 'crate; child(static && mut);' ;
static_collect_to_struct State S
```

Then we run `static_to_local_ref` to pass a reference to the new `State` object
everywhere it is used:

```refactor
select target 'crate; child(static && name("S"));' ;
select user 'crate; desc(fn && !name("main|main_0"));' ;
static_to_local_ref ;
```

The functions that previously accessed the global `S` now use a reference
argument `S_`, removing a source of unsafety.

The only function that still accesses `S` directly is `main_0`.  And since
`main_0` is called only once per run of the program, we can replace the global
`S` with a local variable declared inside `main_0` without affecting the
behavior of the program.  The `static_to_local` command performs the necessary
transformation (using the marks we previous set up for `static_to_local_ref`):

```refactor
static_to_local
```

Now there are no `static mut`s remaining in the program.

There is one final cleanup step to perform.  The struct `State` appears in the
signature of several public functions, but `State` itself is not public, so
`rustc` reports an error.  We could make `State` public, but since there is no
reason for the functions in question to be public in the first place, we make
the functions private instead:

```refactor
select target 'crate; desc(fn && !name("main"));' ;
set_visibility '' ;

commit
```


# `libc` calls






